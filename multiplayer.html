<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêç Yƒ±lan Oyunu - Multiplayer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Poppins:wght@300;400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
            -webkit-overflow-scrolling: auto;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            min-height: 100vh;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            /* min-width: fit-content; REMOVED to fix mobile overflow */
            background-attachment: fixed; /* Ensure gradient stays fixed */
        }

        .container {
            max-width: 1600px; /* Increased to fit wider layout */
            width: 100%;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Logo */
        .logo-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .logo-emoji {
            font-size: 35px;
            display: block;
            margin-bottom: 5px;
        }

        .logo-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 900;
            background: linear-gradient(135deg, #6366f1 0%, #ec4899 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .logo-subtitle {
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Cards */
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            gap: 30px;
            margin-bottom: 40px;
            max-width: 1200px; /* Constrain menu width */
            margin-left: auto;
            margin-right: auto;
        }

        .card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
        }

        .card-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }

        .card h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .card p {
            color: #94a3b8;
            margin-bottom: 20px;
        }

        /* Input */
        input {
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.8);
            color: #f1f5f9;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
        }

        input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
        }

        input::placeholder {
            color: #64748b;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin-top: 20px;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, #34d399 0%, #059669 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
            background: linear-gradient(135deg, #f87171 0%, #dc2626 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(236, 72, 153, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.4);
            background: linear-gradient(135deg, #f472b6 0%, #db2777 100%);
        }

        /* Lobby */
        .lobby-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-id {
            display: inline-block;
            background: rgba(30, 41, 59, 0.8);
            padding: 15px 30px;
            border-radius: 12px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: #f59e0b;
            word-break: break-all;
            max-width: 500px;
            letter-spacing: 3px;
            margin-top: 10px;
        }

        .players-list {
            background: rgba(30, 41, 59, 0.6);
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .player-item {
            background: rgba(15, 23, 42, 0.6);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ready {
            border: 2px solid #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        /* Canvas */
        #game-canvas {
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(99, 102, 241, 0.3);
            display: block;
            margin: 20px auto;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            text-align: center;
            padding: 20px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            margin: 20px 0;
        }

        .score-item {
            padding: 10px 20px;
        }

        .score-label {
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #6366f1;
        }

        .status {
            text-align: center;
            padding: 20px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            margin: 20px 0;
        }

        .hidden {
            display: none !important;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: rgba(30, 41, 59, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .game-over-content h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #fff;
        }

        /* Legend Sidebar */
        .game-sidebar {
            width: 200px;
            flex-shrink: 0;
        }

        .chat-sidebar {
            width: 260px; /* Reduced width to prevent scroll */
            height: 600px; /* Match canvas height */
        }

        .legend-sidebar {
            width: 200px; /* Reduced width */
            height: 600px; /* Match canvas height */
            display: flex;
            justify-content: flex-start;
        }

        .legend-card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 16px;
            padding: 20px;
            width: 100%; /* Fill sidebar */
            height: 100%; /* Fill sidebar */
        }

        .legend-card h3 {
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
            color: #f1f5f9;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .legend-item.bomb {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .legend-item .emoji {
            font-size: 20px;
            margin-right: 10px;
        }

        .legend-item .name {
            flex: 1;
            font-size: 14px;
            color: #cbd5e1;
        }

        .legend-item .points {
            font-weight: bold;
            color: #10b981;
        }

        .legend-item.bomb .points {
            color: #ef4444;
        }

        /* Chat Styles */
        .chat-card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(99, 102, 241, 0.2);
            border-radius: 16px;
            padding: 15px;
            height: 100%;
            /* Removed max-height to let it fill the 600px sidebar */
            display: flex;
            flex-direction: column;
        }

        .chat-card h3 {
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            color: #f1f5f9;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 5px;
            /* max-height handled by flex container */
        }

        .chat-messages::-webkit-scrollbar {
            width: 5px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.5);
            border-radius: 5px;
        }

        .chat-message {
            font-size: 13px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            word-wrap: break-word;
        }

        .chat-message.system {
            font-style: italic;
            color: #94a3b8;
            background: transparent;
            text-align: center;
            font-size: 11px;
        }

        .chat-message.mine {
            background: rgba(99, 102, 241, 0.2);
            align-self: flex-end;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .chat-message.opponent {
            background: rgba(236, 72, 153, 0.2);
            align-self: flex-start;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }

        .chat-message .sender {
            font-size: 10px;
            color: #cbd5e1;
            margin-bottom: 2px;
            display: block;
            font-weight: bold;
        }

        .chat-input-area {
            display: flex;
            gap: 5px;
        }

        .chat-input-area input {
            margin-bottom: 0;
            padding: 10px;
            font-size: 13px;
        }

        .btn-sm {
            padding: 0 15px;
            font-size: 16px;
        }

        /* Updated Overlay Styles */
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 900px;
            height: 600px;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
            backdrop-filter: blur(2px);
        }
        
        /* Mobile fullscreen fix */
        @media (max-width: 1200px) {
            .game-over-overlay {
                position: fixed !important;
                width: 100vw !important;
                height: 100vh !important;
                border-radius: 0 !important;
                z-index: 9999 !important;
            }
            
            .game-over-content {
                width: 90%;
                max-width: 400px;
            }
        }

        /* Countdown Overlay */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: none;
        }

        .countdown-number {
            font-size: 150px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 50px rgba(99, 102, 241, 0.8);
            animation: countdownPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            font-family: 'Orbitron', sans-serif;
        }

        @keyframes countdownPop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Selection UI Styles */
        .customization-section {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .selection-group h3 {
            font-size: 1rem;
            color: #a0a0a0;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .selection-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selection-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .selection-option.active {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
        }

        .preview-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .option-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .vote-count {
            margin-left: auto;
            font-size: 0.8rem;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .promo-icon {
            animation: float 3s ease-in-out infinite;
        }

        .customization-section {
            margin-top: 20px;
        }

        /* REMOVED DUPLICATE customization-section to prevent conflicts */
        /* .customization-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        } */

        .selection-group {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .selection-group h3 {
            margin-bottom: 15px;
            color: #e2e8f0;
            font-size: 1.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .options-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .selection-option {
            background: #2D1B3E; /* Dark purple background */
            border: none;
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
            margin-bottom: 8px;
            text-align: left;
        }

        .selection-option:hover {
            transform: translateY(-2px);
            background: #3D2B4E;
        }

        .selection-option.active {
            border: 2px solid #00E5FF; /* Cyan border for active */
            background: #2D1B3E;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.3);
        }

        .preview-box {
            width: 45px;
            height: 45px;
            flex-shrink: 0;
            margin: 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: transparent; /* Removed background */
        }

        .snake-preview {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .snake-segment {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .snake-head {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-evenly;
            padding-right: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .snake-eye {
            width: 6px;
            height: 6px;
            background: black;
            border-radius: 2px;
            position: relative;
        }

        .option-name {
            display: block;
            font-size: 14px;
            font-weight: 700;
            color: white;
            line-height: 1.2;
        }

        .vote-count {
            display: block;
            font-size: 10px;
            color: #64748b;
            margin-top: 4px;
        }
        
        /* Desktop Layout Styles */
        .lobby-content {
            display: flex;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            align-items: flex-start;
            padding-top: 20px;
        }
        
        .lobby-left {
            width: 300px;
            flex-shrink: 0;
        }
        
        .lobby-center {
            flex: 1;
        }
        
        .lobby-right {
            width: 600px;
            flex-shrink: 0;
        }
        
        .lobby-buttons-container {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .customization-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 0;
        }
        
        .selection-group {
            flex: 1;
        }

        /* ========== MOBILE RESPONSIVE ========== */
        @media (max-width: 1200px) {
            /* Global mobile settings */
            * {
                box-sizing: border-box;
            }
            
            body {
                padding: 0 !important;
                margin: 0 !important;
                overflow-x: hidden !important;
            }
            
            .container {
                max-width: 100vw !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            .screen {
                max-width: 100vw !important;
                width: 100vw !important;
                padding: 10px !important;
                overflow-x: hidden;
            }
            
            /* Menu screen - cards */
            #menu-screen > div > div {
                width: 100% !important;
                padding: 0 5px !important;
            }
            
            .card {
                width: 100% !important;
                max-width: calc(100vw - 30px) !important;
                margin: 10px auto !important;
                box-sizing: border-box !important;
            }
            
            /* Lobby screen */
            #lobby-screen .container {
                padding: 0 5px !important;
            }
            
            /* Lobby cards and sections */
            .lobby-content > div,
            .customization-section,
            .selection-group {
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box !important;
            }
            
            /* Logo */
            .logo-emoji {
                font-size: 40px;
            }
            
            .logo-text {
                font-size: 24px;
            }
            
            .logo-subtitle {
                font-size: 10px;
            }
            
            /* Cards - Stack vertically on mobile */
            .menu-grid {
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: 20px;
            }
            
            .card {
                padding: 20px;
            }
            
            .card-icon {
                font-size: 50px;
            }
            
            .card h2 {
                font-size: 20px;
            }
            
            /* Promo sidebar - move to bottom on mobile */
            div[style*="display: flex"][style*="gap: 30px"] {
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            .promo-sidebar {
                width: 100% !important;
            }
            
            /* Lobby layout - stack vertically */
            .lobby-content {
                flex-direction: column !important;
                gap: 15px !important;
                display: flex !important;
            }
            
            .lobby-left {
                width: 100% !important;
                order: 3; /* Move chat to bottom */
            }
            
            .lobby-center {
                width: 100% !important;
                order: 1; /* Game area in middle */
            }
            
            .lobby-right {
                width: 100% !important;
                order: 2; /* Legend second */
            }
            
            /* Hide sidebars during game on mobile */
            #game-screen .chat-sidebar,
            #game-screen .legend-sidebar {
                display: none !important;
            }
            
            .chat-sidebar {
                width: 100% !important;
                height: 400px !important; /* Larger height for mobile */
                min-height: 400px !important;
                max-height: 400px !important;
            }
            
            /* Also target chat-card directly */
            .chat-card {
                height: 400px !important;
                max-height: 400px !important;
            }
            
            .legend-sidebar {
                width: 100% !important;
                height: auto !important;
                min-height: 200px;
            }
            
            /* Canvas - responsive and full width */
            #game-canvas {
                max-width: 100vw !important;
                width: 100vw !important;
                height: auto !important;
                aspect-ratio: 3/2;
                border-radius: 0 !important;
                margin: 0 !important;
            }
            
            /* Game canvas wrapper */
            .game-main > div {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
                height: auto !important;
            }
            
            /* Game screen */
            #game-screen {
                padding: 0 !important;
                width: 100vw !important;
            }
            
            .game-container-wrapper {
                width: 100% !important;
            }
            
            /* Mobile - Full viewport game screen */
            body {
                overflow-x: hidden;
            }
            
            #game-screen {
                padding: 0 !important;
                width: 100vw !important;
                min-height: 100vh !important;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            #game-screen .container {
                max-width: 100vw !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            /* Lobby content - vertical layout */
            .lobby-content {
                flex-direction: column !important;
                gap: 0 !important;
                padding: 0 !important;
                width: 100vw !important;
            }
            
            /* Game main area */
            .game-main {
                width: 100vw !important;
                max-width: 100vw !important;
                padding: 0 !important;
                margin: 0 !important;
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            
            /* Canvas wrapper - full viewport */
            .game-main > div {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
                height: auto !important;
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Canvas - fit to container */
            #game-canvas {
                max-width: 100vw !important;
                width: 100vw !important;
                height: auto !important;
                aspect-ratio: 3/2;
                border-radius: 0 !important;
                box-shadow: none !important;
            }
            
            /* Score board - compact */
            .game-info {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }
            
            .score-item {
                padding: 8px 15px;
            }
            
            /* Smaller text on mobile */
            .score-label {
                font-size: 12px;
            }
            
            .score-value {
                font-size: 20px;
            }
            
            /* Buttons */
            .btn {
                padding: 12px 20px;
                font-size: 16px;
                cursor: pointer !important;
                pointer-events: auto !important;
                position: relative;
                z-index: 10;
            }
            
            /* Inputs */
            input {
                padding: 12px;
                font-size: 14px;
            }
            
            /* Game ID */
            .game-id {
                font-size: 12px;
                padding: 12px 20px;
                letter-spacing: 2px;
                max-width: 100%;
            }
            
            /* Players list */
            .players-list {
                padding: 15px;
            }
            
            .player-item {
                padding: 12px;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            /* Countdown */
            .countdown-number {
                font-size: 80px;
            }
            
            /* Customization */
            .customization-section {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .selection-group {
                padding: 15px;
            }
            
            .selection-option {
                padding: 8px;
            }
            
            .preview-box {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }
            
            .snake-head {
                width: 32px;
                height: 32px;
            }
            
            .option-name {
                font-size: 13px;
            }
            
            /* Chat */
            .chat-card {
                padding: 12px;
            }
            
            .chat-message {
                font-size: 12px;
                padding: 6px;
            }
            
            .chat-input-area input {
                padding: 8px;
                font-size: 12px;
            }
            
            /* Legend */
            .legend-card {
                padding: 15px;
            }
            
            .legend-item .emoji {
                font-size: 18px;
            }
            
            .legend-item .name {
                font-size: 13px;
            }
            
            /* Game over overlay */
            .game-over-overlay {
                width: 100% !important;
                height: 100% !important;
                position: fixed !important;
            }
            
            .game-over-content {
                padding: 30px 20px;
                max-width: 90%;
            }
            
            .game-over-content h2 {
                font-size: 28px;
            }
            
            /* Score display - horizontal and compact on mobile */
            .game-info {
                flex-direction: row !important;
                justify-content: center !important;
                gap: 15px !important;
                padding: 8px !important;
                margin-top: 5px !important;
            }
            
            .score-item {
                padding: 5px 10px !important;
            }
            
            .score-label {
                font-size: 11px !important;
            }
            
            .score-value {
                font-size: 18px !important;
            }
            
            /* Make game over buttons visible on mobile */
            .game-over-content .btn {
                display: block !important;
                width: 100%;
                margin: 10px 0;
                padding: 15px 20px;
                font-size: 16px;
            }

            /* LOBBY & MENU OVERFLOW FIX - AGGRESSIVE */
            body {
                min-width: 0 !important;
                width: 100% !important;
                overflow-x: hidden !important;
            }

            .container {
                padding: 10px !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                width: 100% !important;
                max-width: 100vw !important;
                overflow-x: hidden !important;
            }

            .lobby-content {
                flex-direction: column !important;
                padding-top: 0 !important;
                gap: 30px !important; /* Increased gap between major sections */
                margin-top: 0 !important;
            }

            .lobby-left, .lobby-center, .lobby-right {
                width: 100% !important;
                max-width: 100% !important;
                flex: none !important;
                margin: 0 !important;
            }
            
            /* Add specific spacing to separate sections */
            .lobby-center {
                margin-bottom: 20px !important;
                border-bottom: 1px solid rgba(255,255,255,0.1); /* Visual separator */
                padding-bottom: 40px !important; /* Increased to prevent overlap */
            }

            .chat-card {
                height: 250px !important; /* Further reduced */
                margin-bottom: 0 !important;
            }
            
            /* Reduce spacing in lobby header */
            .lobby-header {
                margin-bottom: 5px !important;
                margin-top: 5px !important;
            }
            
            .lobby-header h2 {
                font-size: 1.2rem;
                margin-bottom: 2px;
            }
            
            /* Fix button overlap & spacing */
            .lobby-buttons-container {
                margin-top: 10px !important;
                margin-bottom: 20px !important;
                gap: 10px !important;
                padding-bottom: 0 !important;
            }
            
            /* Customization section spacing */
            .lobby-right {
                margin-top: 20px !important; /* Increased spacing */
            }
            
            .customization-section {
                display: flex !important;
                flex-direction: column !important; /* Force vertical stacking */
                margin-top: 0 !important;
                gap: 20px !important;
                width: 100% !important;
            }
            
            .selection-group {
                padding: 10px !important;
                margin-bottom: 10px !important;
            }
            
            /* Menu Screen Compactness */
            .logo-section {
                margin-bottom: 5px !important;
                margin-top: 5px !important;
            }
            
            .logo-emoji {
                font-size: 24px !important;
                margin-bottom: 0 !important;
            }
            
            .logo-text {
                font-size: 20px !important;
                margin-bottom: 0 !important;
            }
            
            .logo-subtitle {
                font-size: 9px !important;
            }
            
            /* Menu Grid & Cards */
            .menu-grid {
                gap: 10px !important;
                margin-bottom: 10px !important;
                display: flex !important;
                flex-direction: column !important;
            }
            
            .card {
                padding: 15px !important;
                margin: 0 !important;
                width: 100% !important;
                max-width: 100% !important;
            }
            
            .card-icon {
                font-size: 30px !important;
                margin-bottom: 5px !important;
            }
            
            .card h2 {
                font-size: 18px !important;
                margin-bottom: 5px !important;
            }
            
            .card p {
                margin-bottom: 10px !important;
                font-size: 12px !important;
            }
            
            /* Promo Sidebar in Menu */
            .promo-sidebar {
                width: 100% !important;
                margin-top: 10px !important;
            }
            
            .promo-card {
                padding: 15px !important;
            }
            
            .promo-icon {
                font-size: 2.5rem !important;
                margin-bottom: 5px !important;
            }
            
            .promo-title {
                font-size: 1.5rem !important;
                margin: 5px 0 !important;
            }
            
            .promo-username {
                font-size: 1.2rem !important;
                margin: 5px 0 !important;
            }
            
            .promo-text {
                margin: 10px 0 !important;
                font-size: 0.85rem !important;
            }
            
            .promo-button {
                margin-top: 10px !important;
                padding: 10px 20px !important;
                margin-bottom: 0 !important; /* Ensure no bottom margin */
            }
            
            /* Remove space below promo card */
            .promo-card {
                padding-bottom: 15px !important;
                margin-bottom: 0 !important;
            }
            
            /* Remove space below chat card in lobby */
            .lobby-left {
                margin-bottom: 0 !important;
                padding-bottom: 0 !important;
            }
            
            .chat-card {
                height: 250px !important;
                margin-bottom: 0 !important;
                padding-bottom: 10px !important;
            }
            
            /* Reduce gap between chat and center */
            .lobby-content {
                gap: 10px !important; /* Reduced from 30px */
            }
            
            /* Adjust center section spacing */
            .lobby-center {
                margin-top: 10px !important;
                margin-bottom: 10px !important;
                padding-bottom: 10px !important;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Menu -->
        <div id="menu-screen" class="screen active">
            <div class="logo-section">
                <span class="logo-emoji">üêç</span>
                <h1 class="logo-text">Yƒ±lan Oyunu</h1>
                <p class="logo-subtitle">Multiplayer Edition</p>
            </div>

            <div style="display: flex; gap: 30px; max-width: 1400px; margin: 0 auto; align-items: flex-start;">
                <!-- Game Cards -->
                <div style="display: flex; gap: 20px; flex: 1;">
                    <div class="card">
                        <div class="card-icon">üéÆ</div>
                        <h2>Oyun Olu≈ütur</h2>
                        <p>Yeni oyun ba≈ülat</p>
                        <input type="text" id="host-name" placeholder="ƒ∞sminizi girin" maxlength="15">
                        <button class="btn btn-primary" onclick="createGame()">Oyun Olu≈ütur</button>
                    </div>

                    <div class="card">
                        <div class="card-icon">üö™</div>
                        <h2>Oyuna Katƒ±l</h2>
                        <p>Arkada≈üƒ±nƒ±n oyununa katƒ±l</p>
                        <input type="text" id="guest-name" placeholder="ƒ∞sminizi girin" maxlength="15">
                        <input type="text" id="room-id" placeholder="Oyun ID'si" maxlength="50">
                        <button class="btn btn-secondary" onclick="joinGame()">Katƒ±l</button>
                    </div>
                </div>

                <!-- Promo Sidebar -->
                <div class="promo-sidebar" style="width: 320px; flex-shrink: 0;">
                    <div class="promo-card" style="background: rgba(30, 41, 59, 0.8); border-radius: 20px; padding: 40px 30px; text-align: center; border: 2px solid rgba(99, 102, 241, 0.2);">
                        <div class="promo-icon" style="font-size: 4rem; margin-bottom: 20px; filter: drop-shadow(0 0 20px rgba(255, 140, 0, 0.6));">üì∏</div>
                        <h3 class="promo-title" style="color: #ff8c00; font-size: 2rem; font-weight: 700; margin: 10px 0;">Takip Et!</h3>
                        <div class="promo-username" style="color: #00d9ff; font-size: 1.5rem; font-weight: 600; margin: 10px 0;">@kaan.doc</div>
                        <p class="promo-text" style="color: rgba(255, 255, 255, 0.6); font-size: 0.95rem; margin: 20px 0;">Instagram'da benimle baƒülantƒ±da kalƒ±n</p>
                        <a href="https://instagram.com/kaan.doc" target="_blank" rel="noopener" class="promo-button" style="display: flex; align-items: center; justify-content: center; gap: 12px; padding: 15px 30px; background: linear-gradient(90deg, #ff6b35 0%, #f7598d 50%, #e91e63 100%); border-radius: 12px; color: white; text-decoration: none; font-weight: 600; font-size: 1rem; transition: transform 0.2s; margin-top: 25px;">
                            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="flex-shrink: 0">
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M7.46154 0C3.34062 0 0 3.34062 0 7.46154V16.5385C0 20.6594 3.34062 24 7.46154 24H16.5385C20.6594 24 24 20.6594 24 16.5385V7.46154C24 3.34062 20.6594 0 16.5385 0H7.46154ZM16.5385 2.18182H7.46154C4.5456 2.18182 2.18182 4.5456 2.18182 7.46154V16.5385C2.18182 19.4544 4.5456 21.8182 7.46154 21.8182H16.5385C19.4544 21.8182 21.8182 19.4544 21.8182 16.5385V7.46154C21.8182 4.5456 19.4544 2.18182 16.5385 2.18182ZM12 5.81818C8.58578 5.81818 5.81818 8.58578 5.81818 12C5.81818 15.4142 8.58578 18.1818 12 18.1818C15.4142 18.1818 18.1818 15.4142 18.1818 12C18.1818 8.58578 15.4142 5.81818 12 5.81818ZM12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8ZM18.7273 6.36364C19.3298 6.36364 19.8182 5.87523 19.8182 5.27273C19.8182 4.67023 19.3298 4.18182 18.7273 4.18182C18.1248 4.18182 17.6364 4.67023 17.6364 5.27273C17.6364 5.87523 18.1248 6.36364 18.7273 6.36364Z" fill="white"/>
                            </svg>
                            <div style="display: flex; flex-direction: column; align-items: flex-start;">
                                <span style="font-size: 0.75rem; opacity: 0.9;">Instagram'da</span>
                                <span style="font-size: 1.05rem; font-weight: 700;">Takip Et</span>
                            </div>
                        </a>
                    </div>
                </div>
            </div>

            <div class="status hidden" id="status">
                <p id="status-text">Baƒülanƒ±yor...</p>
            </div>
        </div>

        <!-- Lobby -->
        <div id="lobby-screen" class="screen">
            <div class="lobby-content">
                <!-- Left: Chat -->
                <div class="lobby-left">
                    <div class="chat-card" style="height: 600px; margin: 0;">
                        <h3>Sohbet</h3>
                        <div id="lobby-chat-messages" class="chat-messages">
                            <div class="chat-message system">Lobiye ho≈ü geldiniz!</div>
                        </div>
                        <div class="chat-input-area">
                            <input type="text" id="lobby-chat-input" placeholder="Mesaj yaz..." maxlength="50">
                            <button class="btn btn-primary btn-sm" onclick="sendChatMessage('lobby-chat-input')">‚Üí</button>
                        </div>
                    </div>
                </div>

                <!-- Center: Game Info & Players -->
                <div class="lobby-center">
                    <div class="lobby-header" style="margin-bottom: 20px;">
                        <h2>üéÆ Oyun Lobisi</h2>
                        <div class="id-container" style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 10px;">
                            <div class="game-id" id="game-id-mask">******</div>
                            <div class="game-id" id="game-id-display" style="display: none;"></div>
                            <button class="btn btn-sm btn-secondary" onclick="toggleIdVisibility()" style="width: auto; padding: 10px 15px;">üëÅÔ∏è</button>
                        </div>
                        <button class="btn btn-primary" onclick="copyGameId()" style="margin-top: 15px; max-width: 300px; margin-left: auto; margin-right: auto;">üìã ID'yi Kopyala</button>
                    </div>

                    <div class="players-list">
                        <h3>Oyuncular</h3>
                        <div id="players-list"></div>
                    </div>

                    <div class="lobby-buttons-container">
                        <button id="ready-btn" class="btn btn-success" onclick="toggleReady()" style="margin-top: 0;">Hazƒ±r</button>
                        <button class="btn btn-secondary" onclick="backToMenu()">√áƒ±kƒ±≈ü</button>
                    </div>
                </div>

                <!-- Right: Customization -->
                <div class="lobby-right">
                    <div class="customization-section">
                        <div class="selection-group">
                            <h3>üêç Yƒ±lan G√∂r√ºn√ºm√º</h3>
                            <div id="skin-options" class="options-grid">
                                <!-- Skins will be populated here -->
                            </div>
                        </div>

                        <div class="selection-group">
                            <h3>üó≥Ô∏è Harita Oylamasƒ±</h3>
                            <div id="map-options" class="options-grid">
                                <!-- Maps will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game -->
        <div id="game-screen" class="screen">
            <div class="game-layout" style="display: flex; gap: 10px; align-items: flex-start; justify-content: center; height: 100vh; padding-top: 20px;">
                
                <!-- Left Sidebar Chat -->
                <div class="game-sidebar chat-sidebar">
                    <div class="chat-card">
                        <h3>Sohbet</h3>
                        <div id="game-chat-messages" class="chat-messages">
                            <div class="chat-message system">Sohbete ho≈ü geldiniz!</div>
                        </div>
                        <div class="chat-input-area">
                            <input type="text" id="game-chat-input" placeholder="Mesaj yaz..." maxlength="50">
                            <button class="btn btn-primary btn-sm" onclick="sendChatMessage('game-chat-input')">‚Üí</button>
                        </div>
                    </div>
                </div>

                <div class="game-main" style="position: relative; width: 900px;">
                    <!-- Canvas Wrapper for correct overlay positioning -->
                    <div style="position: relative; width: 900px; height: 600px; margin: 0 auto 20px auto;">
                        <canvas id="game-canvas" width="900" height="600" style="display: block; width: 100%; height: 100%; margin: 0; box-shadow: 0 0 50px rgba(0,0,0,0.5); border-radius: 12px;"></canvas>
                        
                        <!-- Game Over Overlay -->
                        <div id="game-over-overlay" class="game-over-overlay hidden">
                            <div class="game-over-content">
                                <h2 id="game-over-title">Oyun Bitti!</h2>
                                <p id="game-over-message" style="font-size: 20px; margin: 20px 0;"></p>
                                <p id="restart-status" style="color: #94a3b8; margin: 10px 0;">Tekrar oynamak i√ßin hazƒ±r ol</p>
                                <button class="btn btn-success" onclick="readyForRestart()">üîÑ Yeniden Oyna</button>
                                <button class="btn btn-secondary" onclick="backToMenu()" style="margin-top: 10px;">‚Üê Ana Men√º</button>
                            </div>
                        </div>
                        
                        <!-- Countdown Overlay -->
                        <div id="countdown-overlay" class="countdown-overlay hidden">
                            <div id="countdown-text" class="countdown-number">3</div>
                        </div>
                        
                        <!-- Final Countdown (when 1 player left) -->
                        <div id="final-countdown" style="display: none; position: absolute; top: 5px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); padding: 5px 12px; border-radius: 6px; border: 1px solid #fbbf24; z-index: 100;">
                            <div style="font-size: 11px; color: #fbbf24; font-weight: bold; text-align: center;">Son Oyuncu</div>
                            <div id="final-countdown-time" style="font-size: 20px; color: #fff; font-weight: bold; text-align: center;">5</div>
                        </div>
                    </div>

                    <div class="game-info" id="score-board" style="margin-top: -30px;">
                        <!-- Scores will be populated here -->
                    </div>
                </div>

                <!-- Right Sidebar Legend -->
                <div class="game-sidebar legend-sidebar">
                    <div class="legend-card">
                        <h3>Puan Tablosu</h3>
                        <div class="legend-item">
                            <span class="emoji">üçé</span>
                            <span class="name">Elma</span>
                            <span class="points">+10</span>
                        </div>
                        <div class="legend-item">
                            <span class="emoji">üçä</span>
                            <span class="name">Portakal</span>
                            <span class="points">+15</span>
                        </div>
                        <div class="legend-item">
                            <span class="emoji">üçã</span>
                            <span class="name">Limon</span>
                            <span class="points">+12</span>
                        </div>
                        <div class="legend-item">
                            <span class="emoji">üçá</span>
                            <span class="name">√úz√ºm</span>
                            <span class="points">+20</span>
                        </div>
                        <div class="legend-item">
                            <span class="emoji">üçì</span>
                            <span class="name">√áilek</span>
                            <span class="points">+18</span>
                        </div>
                        <div class="legend-divider"></div>
                        <div class="legend-item bomb">
                            <span class="emoji">üí£</span>
                            <span class="name">Bomba</span>
                            <span class="points">-20</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // Game constants
        const GRID_SIZE = 25;
        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 600;
        const GRID_COUNT_X = CANVAS_WIDTH / GRID_SIZE;
        const GRID_COUNT_Y = CANVAS_HEIGHT / GRID_SIZE;
        const GAME_SPEED = 100;
        const MAX_PLAYERS = 4;

        // Snake Skins
        // Snake Skins
        const SNAKE_SKINS = [
            { id: 'toxic', name: 'Zehirli Ye≈üil', head: '#39FF14', body: '#008000', glow: '#39FF14' },
            { id: 'cyber', name: 'Neon Cyber', head: '#FF00FF', body: '#9D00FF', glow: '#FF00FF' },
            { id: 'magma', name: 'Magma Ate≈üi', head: '#FF4500', body: '#FF8C00', glow: '#FF4500' },
            { id: 'gold', name: 'Altƒ±n L√ºks', head: '#FFD700', body: '#DAA520', glow: '#FFD700' },
            { id: 'galaxy', name: 'Galaktik Mor', head: '#9370DB', body: '#8A2BE2', glow: '#9370DB' }
        ];

        // Maps
        const MAPS = [
            {
                id: 'classic',
                name: 'Klasik Arena',
                emoji: 'üéÆ',
                bgColor: 'rgba(0, 0, 0, 0.3)',
                gridColor: 'rgba(255, 255, 255, 0.05)',
                drawPattern: (ctx) => {}
            },
            {
                id: 'grass',
                name: '√áimenli Bah√ße',
                emoji: 'üåª',
                bgColor: 'rgba(50, 205, 50, 0.3)',
                gridColor: 'rgba(144, 238, 144, 0.2)',
                drawPattern: (ctx) => {
                    ctx.fillStyle = 'rgba(0, 100, 0, 0.15)';
                    for (let i = 0; i < 60; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        const h = 5 + Math.random() * 8;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + 3, y - h);
                        ctx.lineTo(x + 6, y);
                        ctx.fill();
                    }
                }
            },
            {
                id: 'magma',
                name: 'Volkanik Vadi',
                emoji: 'üåã',
                bgColor: 'rgba(139, 0, 0, 0.3)',
                gridColor: 'rgba(255, 69, 0, 0.2)',
                drawPattern: (ctx) => {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    for (let i = 0; i < 50; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        const size = 2 + Math.random() * 4;
                        ctx.fillRect(x, y, size, size);
                    }
                }
            },
            {
                id: 'desert',
                name: 'Kƒ±zgƒ±n Kumlar',
                emoji: 'üåµ',
                bgColor: 'rgba(210, 180, 140, 0.3)',
                gridColor: 'rgba(255, 215, 0, 0.2)',
                drawPattern: (ctx) => {
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 20; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.quadraticCurveTo(x + 10, y - 10, x + 20, y);
                        ctx.stroke();
                    }
                }
            },
            {
                id: 'ocean',
                name: 'Derin Okyanus',
                emoji: 'üåä',
                bgColor: 'rgba(0, 0, 139, 0.3)',
                gridColor: 'rgba(0, 191, 255, 0.2)',
                drawPattern: (ctx) => {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 40; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        const r = 2 + Math.random() * 5;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
        ];

        // Fruit types
        const FRUITS = [
            { emoji: 'üçé', name: 'Apple', points: 10, color: '#FF4444' },
            { emoji: 'üçä', name: 'Orange', points: 15, color: '#FF8C00' },
            { emoji: 'üçã', name: 'Lemon', points: 12, color: '#FFD700' },
            { emoji: 'üçá', name: 'Grape', points: 20, color: '#9370DB' },
            { emoji: 'üçì', name: 'Strawberry', points: 18, color: '#FF69B4' }
        ];

        // State
        let peer = null;
        let myId = null;
        let isHost = false;
        let connection = null; // For guest
        let connections = []; // For host
        let players = {};
        let myName = '';
        let isReady = false;
        
        // Game state
        let canvas, ctx;
        let mySnake = [];
        let food = null;
        let bomb = null; // Bomb object
        let explosion = null; // Explosion effect {x, y, frame}
        let myDx = 1, myDy = 0;
        let myScore = 0;
        let isPlaying = false;
        let gameInterval = null;
        let myRestartReady = false;

        // Selections
        let mySkinId = 'random';
        let myMapVote = 'random';
        let currentMap = MAPS[0]; // Default for rendering before start
        let myAlive = true;
        let lastKeyPressed = 'None'; // For debugging

        
        // Helper to get opponent ID
        function getOpponentId() {
            return Object.keys(players).find(id => id !== myId);
        }

        // Initialize canvas
        function initCanvas() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
        }

        // Show screen
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        // Generate short ID
        function generateShortId() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        // PeerJS Configuration with STUN servers
        const peerConfig = {
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ]
            }
        };

        // Create game
        function createGame() {
            myName = 'Oyuncu 1'; // Host is always Player 1
            document.getElementById('status').classList.remove('hidden');
            document.getElementById('status-text').textContent = 'Oyun olu≈üturuluyor...';

            const shortId = generateShortId();
            peer = new Peer(shortId, peerConfig);
            
            peer.on('open', (id) => {
                myId = id;
                isHost = true;
                players[myId] = { name: myName, ready: false, skinId: mySkinId, mapVote: myMapVote };
                
                document.getElementById('status').classList.add('hidden');
                showScreen('lobby-screen');
                
                // Set ID
                const idDisplay = document.getElementById('game-id-display');
                idDisplay.textContent = id;
                
                // Ensure mask is visible and ID is hidden initially
                document.getElementById('game-id-mask').style.display = 'block';
                idDisplay.style.display = 'none';
                
                updatePlayersList();
                
                // Initialize selections with delay to ensure DOM is ready
                setTimeout(() => {
                    console.log('Calling initSelections after delay');
                    initSelections();
                }, 500);

                peer.on('connection', (conn) => {
                    // Check if room is full
                    if (Object.keys(players).length >= MAX_PLAYERS) {
                        conn.on('open', () => {
                            conn.send({ type: 'error', message: 'Oyun dolu! (Maksimum 4 oyuncu)' });
                            setTimeout(() => conn.close(), 500);
                        });
                        return;
                    }

                    connections.push(conn);
                    setupConnection(conn);
                });
            });

            peer.on('error', (err) => {
                if (err.type === 'unavailable-id') {
                    // Retry with new ID if taken
                    peer.destroy();
                    createGame();
                    return;
                }
                alert('Hata: ' + err.message);
                document.getElementById('status').classList.add('hidden');
            });
        }

        // Initialize Selections
        function initSelections() {
            console.log('initSelections called');
            try {
                // Skins
                const skinContainer = document.getElementById('skin-options');
                if (!skinContainer) {
                    console.error('Skin container not found!');
                    return;
                }
                skinContainer.innerHTML = '';
                
                if (!SNAKE_SKINS || SNAKE_SKINS.length === 0) {
                    console.error('SNAKE_SKINS not defined or empty!');
                    alert('Hata: Yƒ±lan g√∂r√ºn√ºmleri y√ºklenemedi!');
                    return;
                }

                // Add Random Option for Skins
                const randomSkinEl = document.createElement('div');
                randomSkinEl.className = `selection-option ${mySkinId === 'random' ? 'active' : ''}`;
                randomSkinEl.onclick = () => selectSkin('random');
                randomSkinEl.innerHTML = `
                    <div class="preview-box">üé≤</div>
                    <span class="option-name">Rastgele</span>
                `;
                skinContainer.appendChild(randomSkinEl);

                SNAKE_SKINS.forEach(skin => {
                    const el = document.createElement('div');
                    el.className = `selection-option ${skin.id === mySkinId ? 'active' : ''}`;
                    el.onclick = () => selectSkin(skin.id);
                    
                    const headColor = skin.head || skin.headColor;
                    const bodyColor = skin.body || skin.bodyColor;
                    const glowColor = skin.glow || skin.glowColor;

                    el.innerHTML = `
                        <div class="preview-box">
                            <div class="snake-preview" style="position: relative; width: 30px; height: 30px;">
                                <div class="snake-segment" style="background: ${bodyColor}; position: absolute; right: -3px; bottom: -3px; width: 30px; height: 30px; border-radius: 8px; opacity: 0.5;"></div>
                                <div class="snake-head" style="background: ${headColor}; box-shadow: 0 0 10px ${glowColor}; position: absolute; z-index: 2; width: 30px; height: 30px; border-radius: 8px;">
                                    <div class="snake-eye" style="width: 4px; height: 4px;"></div>
                                    <div class="snake-eye" style="width: 4px; height: 4px;"></div>
                                </div>
                            </div>
                        </div>
                        <span class="option-name">${skin.name}</span>
                    `;
                    skinContainer.appendChild(el);
                    console.log('Added skin:', skin.name);
                });

                // Maps
                const mapContainer = document.getElementById('map-options');
                if (!mapContainer) return;
                mapContainer.innerHTML = '';
                
                // Add Random Option
                const randomEl = document.createElement('div');
                randomEl.className = `selection-option ${myMapVote === 'random' ? 'active' : ''}`;
                randomEl.onclick = () => voteMap('random');
                randomEl.innerHTML = `
                    <div class="preview-box">üé≤</div>
                    <span class="option-name">Rastgele</span>
                `;
                mapContainer.appendChild(randomEl);

                // Add Map Options
                MAPS.forEach(map => {
                    const el = document.createElement('div');
                    el.className = `selection-option ${map.id === myMapVote ? 'active' : ''}`;
                    el.onclick = () => voteMap(map.id);
                    el.innerHTML = `
                        <div class="preview-box" style="background: ${map.bgColor}40; border: 1px solid ${map.bgColor}80;">${map.emoji}</div>
                        <span class="option-name">${map.name}</span>
                    `;
                    mapContainer.appendChild(el);
                });
            } catch (e) {
                alert('Selection Error: ' + e.message);
            }
        }

        function selectSkin(id) {
            mySkinId = id;
            initSelections(); // Re-render to update active class
            
            // Update local player object and list
            if (players[myId]) {
                players[myId].skinId = mySkinId;
                updatePlayersList();
            }

            broadcast({ type: 'updatePlayer', skinId: mySkinId, mapVote: myMapVote });
        }

        function voteMap(id) {
            myMapVote = id;
            initSelections(); // Re-render
            
            // Update local player object and list
            if (players[myId]) {
                players[myId].mapVote = myMapVote;
                updatePlayersList();
            }

            broadcast({ type: 'updatePlayer', skinId: mySkinId, mapVote: myMapVote });
        }


        // Join game
        function joinGame() {
            const roomId = document.getElementById('room-id').value.trim();
            // Auto-assign player number based on existing players
            myName = ''; // Will be set after receiving player list from host
            
            if (!roomId) {
                alert('L√ºtfen oyun ID\'si girin!');
                return;
            }

            document.getElementById('status').classList.remove('hidden');
            document.getElementById('status-text').textContent = 'Baƒülanƒ±yor...';

            // Initialize selections for guest
            initSelections();

            peer = new Peer(null, peerConfig);
            
            peer.on('open', (id) => {
                myId = id;
                isHost = false;
                
                connection = peer.connect(roomId);
                
                connection.on('open', () => {
                    connection.send({ 
                        type: 'join', 
                        name: myName, 
                        id: myId,
                        skinId: mySkinId,
                        mapVote: myMapVote
                    });
                    setupConnection(connection);
                });

                connection.on('error', () => {
                    alert('Baƒülantƒ± hatasƒ±!');
                    document.getElementById('status').classList.add('hidden');
                });
            });
        }

        // Setup connection
        function setupConnection(conn) {
            conn.on('data', (data) => {
                if (data.type === 'join') {
                    // Assign sequential player number
                    const playerNumber = Object.keys(players).length + 1;
                    const assignedName = `Oyuncu ${playerNumber}`;
                    
                    players[data.id] = { 
                        name: assignedName,  // Use assigned name
                        ready: false,
                        skinId: data.skinId || SNAKE_SKINS[0].id,
                        mapVote: data.mapVote || 'random',
                        score: 0
                    };
                    
                    // Send assigned name back to player
                    conn.send({
                        type: 'assignName',
                        yourName: assignedName
                    });
                    
                    updatePlayersList();
                    if (isHost) {
                        // Broadcast new player list to ALL connected players
                        broadcast({ type: 'players', players: players });
                    }
                    addChatMessage(`${data.name} katƒ±ldƒ±!`, 'Sistem', false);
                } else if (data.type === 'assignName') {
                    // Update our name with host-assigned name
                    myName = data.yourName;
                    console.log('[Guest] Assigned name:', myName);
                } else if (data.type === 'players') {
                    players = data.players;
                    document.getElementById('status').classList.add('hidden');
                    showScreen('lobby-screen');
                    updatePlayersList();
                    
                    // Re-initialize selections to ensure DOM is ready
                    setTimeout(() => {
                        initSelections();
                    }, 100);
                } else if (data.type === 'updatePlayer') {
                    if (players[conn.peer]) {
                        players[conn.peer].skinId = data.skinId;
                        players[conn.peer].mapVote = data.mapVote;
                        updatePlayersList();
                        
                        // If host, broadcast update to others
                        if (isHost) {
                            broadcast({ type: 'players', players: players });
                        }
                    }
                } else if (data.type === 'ready') {
                    players[data.id].ready = data.ready;
                    updatePlayersList();
                    
                    // If host, broadcast ready status
                    if (isHost) {
                        broadcast({ type: 'ready', id: data.id, ready: data.ready });
                    }
                    
                    checkAllReady();
                } else if (data.type === 'start') {
                    // Set map from host decision
                    if (data.mapId) {
                        const foundMap = MAPS.find(m => m.id === data.mapId);
                        if (foundMap) currentMap = foundMap;
                    }
                    startGame(data.food);
                } else if (data.type === 'move') {
                    // Host receiving move from guest - IMMEDIATELY update direction
                    if (isHost && players[data.id]) {
                        // Update direction first (most important)
                        players[data.id].dx = data.dx;
                        players[data.id].dy = data.dy;
                        // Then update other state
                        players[data.id].snake = data.snake;
                        players[data.id].score = data.score;
                        players[data.id].alive = data.alive;
                    }
                } else if (data.type === 'stateUpdate') {
                    // Guest receiving full state from host
                    if (!isHost) {
                        Object.keys(data.players).forEach(id => {
                            if (id !== myId && players[id]) {
                                players[id].snake = data.players[id].snake;
                                players[id].score = data.players[id].score;
                                players[id].alive = data.players[id].alive;
                                players[id].dx = data.players[id].dx;
                                players[id].dy = data.players[id].dy;
                                
                                // Update opponent score display (sum of others? or list?)
                                // For now, just show first opponent's score or max
                                // Better: Update leaderboard
                            }
                        });
                        food = data.food;
                        bomb = data.bomb;
                    }
                } else if (data.type === 'gameOver') {
                    if (isPlaying) {
                        showGameOver(data.winner);
                    }
                } else if (data.type === 'restartReady') {
                    if (players[data.id]) {
                        players[data.id].restartReady = data.ready;
                        updateRestartStatus();
                        
                        if (isHost) {
                            broadcast({ type: 'restartReady', id: data.id, ready: data.ready });
                            checkAllReadyForRestart();
                        }
                    }
                } else if (data.type === 'restart') {
                    restartGame(data.food);
                } else if (data.type === 'chat') {
                    addChatMessage(data.message, data.sender, false);
                    // If host, relay to others
                    if (isHost) {
                        broadcast({ type: 'chat', message: data.message, sender: data.sender }, conn); // Skip sender
                    }
                }
            });
        }

        // Helper to broadcast message to all connected peers
        function broadcast(msg, excludeConn = null) {
            if (isHost) {
                connections.forEach(conn => {
                    if (conn !== excludeConn && conn.open) {
                        conn.send(msg);
                    }
                });
            } else if (connection && connection.open) {
                // Guest simply sends to host
                connection.send(msg);
            }
        }

        // Chat Functions
        function sendChatMessage(inputId) {
            const input = document.getElementById(inputId);
            const message = input.value.trim();
            
            if (message) {
                // Add to my chat
                addChatMessage(message, 'Ben', true);
                
                // Send to others
                broadcast({
                    type: 'chat',
                    message: message,
                    sender: myName
                });
                
                input.value = '';
            }
        }

        function addChatMessage(message, sender, isMe) {
            // Add to both lobby and game chat to keep them synced
            ['lobby-chat-messages', 'game-chat-messages'].forEach(id => {
                const chatMessages = document.getElementById(id);
                if (!chatMessages) return;

                const msgDiv = document.createElement('div');
                msgDiv.className = `chat-message ${isMe ? 'mine' : 'opponent'}`;
                
                // Escape HTML to prevent XSS
                const safeMessage = message.replace(/&/g, "&amp;")
                                           .replace(/</g, "&lt;")
                                           .replace(/>/g, "&gt;")
                                           .replace(/"/g, "&quot;")
                                           .replace(/'/g, "&#039;");
                
                msgDiv.innerHTML = `
                    <span class="sender">${sender}</span>
                    ${safeMessage}
                `;
                
                chatMessages.appendChild(msgDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        }

        // Add Enter key support for chat
        ['lobby-chat-input', 'game-chat-input'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendChatMessage(id);
                    }
                });
                // Prevent arrow keys from scrolling in chat input
                el.addEventListener('keydown', function(e) {
                    e.stopPropagation(); 
                });
            }
        });

        // Update players list
        function updatePlayersList() {
            const list = document.getElementById('players-list');
            list.innerHTML = '';
            
            Object.keys(players).forEach(id => {
                const player = players[id];
                const div = document.createElement('div');
                div.className = 'player-item' + (player.ready ? ' ready' : '');
                
                // Get Skin Name
                const skin = SNAKE_SKINS.find(s => s.id === player.skinId);
                const skinName = skin ? skin.name : (player.skinId === 'random' ? 'üé≤ Rastgele' : 'Bilinmiyor');

                // Get Map Name
                const map = MAPS.find(m => m.id === player.mapVote);
                const mapName = map ? map.name : (player.mapVote === 'random' ? 'üé≤ Rastgele' : 'Bilinmiyor');

                div.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <span style="font-weight: 600;">${player.name} ${id === myId ? '(Sen)' : ''}</span>
                        <div style="font-size: 0.8rem; color: #94a3b8; display: flex; gap: 10px;">
                            <span>üêç ${skinName}</span>
                            <span>üó∫Ô∏è ${mapName}</span>
                        </div>
                    </div>
                    <span>${player.ready ? '‚úì Hazƒ±r' : 'Bekliyor...'}</span>
                `;
                list.appendChild(div);
            });
        }

        // Toggle ready
        function toggleReady() {
            isReady = !isReady;
            players[myId].ready = isReady;
            updatePlayersList();
            
            // Update button style
            const btn = document.getElementById('ready-btn');
            if (isReady) {
                btn.textContent = 'Hazƒ±r Deƒüil';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-danger');
            } else {
                btn.textContent = 'Hazƒ±r';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-success');
            }
            
            if (connection || isHost) {
                broadcast({ type: 'ready', id: myId, ready: isReady });
            }
            
            checkAllReady();
        }

        // Check all ready
        function checkAllReady() {
            const allReady = Object.values(players).every(p => p.ready);
            if (allReady && Object.keys(players).length >= 2) {
                if (isHost) {
                    // Decide Map
                    const votes = {};
                    Object.values(players).forEach(p => {
                        const vote = p.mapVote || 'random';
                        votes[vote] = (votes[vote] || 0) + 1;
                    });

                    let selectedMapId = 'classic';
                    
                    // Check for random
                    if (votes['random'] && votes['random'] >= Object.keys(players).length / 2) {
                        // Majority random or all random
                        const randomMap = MAPS[Math.floor(Math.random() * MAPS.length)];
                        selectedMapId = randomMap.id;
                    } else {
                        // Find winner
                        let maxVotes = 0;
                        let winners = [];
                        
                        // Filter out 'random' for specific map count
                        Object.keys(votes).forEach(id => {
                            if (id !== 'random') {
                                if (votes[id] > maxVotes) {
                                    maxVotes = votes[id];
                                    winners = [id];
                                } else if (votes[id] === maxVotes) {
                                    winners.push(id);
                                }
                            }
                        });

                        if (winners.length > 0) {
                            // Pick random from winners (if tie)
                            selectedMapId = winners[Math.floor(Math.random() * winners.length)];
                        } else {
                            // Fallback if only random votes existed but logic fell through
                            const randomMap = MAPS[Math.floor(Math.random() * MAPS.length)];
                            selectedMapId = randomMap.id;
                        }
                    }

                    // Resolve Random Skins
                    // Resolve Random Skins
                    const assignedSkins = new Set();
                    // First pass: collect non-random skins
                    Object.keys(players).forEach(pid => {
                        if (players[pid].skinId && players[pid].skinId !== 'random') {
                            assignedSkins.add(players[pid].skinId);
                        }
                    });

                    // Second pass: assign random skins
                    Object.keys(players).forEach(pid => {
                        if (players[pid].skinId === 'random' || !players[pid].skinId) {
                            // Filter available skins if possible, otherwise pick any
                            let availableSkins = SNAKE_SKINS.filter(s => !assignedSkins.has(s.id));
                            if (availableSkins.length === 0) availableSkins = SNAKE_SKINS;
                            
                            const randomSkin = availableSkins[Math.floor(Math.random() * availableSkins.length)];
                            players[pid].skinId = randomSkin.id;
                            assignedSkins.add(randomSkin.id);
                        }
                    });
                    
                    // Sync resolved skins to clients
                    broadcast({ type: 'players', players: players });

                    const initialFood = createFood();
                    broadcast({ type: 'start', food: initialFood, mapId: selectedMapId });
                    
                    // Set local map
                    const foundMap = MAPS.find(m => m.id === selectedMapId);
                    if (foundMap) currentMap = foundMap;
                    
                    startGame(initialFood);
                }
            }
        }

        // Create food
        function createFood() {
            const randomFruit = FRUITS[Math.floor(Math.random() * FRUITS.length)];
            return {
                x: Math.floor(Math.random() * GRID_COUNT_X),
                y: Math.floor(Math.random() * GRID_COUNT_Y),
                type: randomFruit
            };
        }
        
        // Create bomb (10% chance - rare)
        function createBomb() {
            if (Math.random() < 0.1) {
                return {
                    x: Math.floor(Math.random() * GRID_COUNT_X),
                    y: Math.floor(Math.random() * GRID_COUNT_Y)
                };
            }
            return null;
        }

        // Start game
        function startGame(initialFood, resetScores = true) {
            // Stop any existing game loop immediately
            if (gameInterval) clearInterval(gameInterval);
            isPlaying = false;
            
            showScreen('game-screen');
            initCanvas();
            
            // Initialize snakes for all players
            const playerIds = Object.keys(players);
            
            playerIds.forEach((id, index) => {
                let startX, startY, dx, dy;
                
                // 4-Player Spawn Logic (Corners)
                switch(index) {
                    case 0: // Top-Left
                        startX = 3; startY = 3;
                        dx = 1; dy = 0;
                        break;
                    case 1: // Bottom-Right
                        startX = GRID_COUNT_X - 4; startY = GRID_COUNT_Y - 4;
                        dx = -1; dy = 0;
                        break;
                    case 2: // Top-Right
                        startX = GRID_COUNT_X - 4; startY = 3;
                        dx = -1; dy = 0;
                        break;
                    case 3: // Bottom-Left
                        startX = 3; startY = GRID_COUNT_Y - 4;
                        dx = 1; dy = 0;
                        break;
                    default: // Fallback
                        startX = 10; startY = 10;
                        dx = 1; dy = 0;
                }

                players[id].snake = [
                    { x: startX, y: startY },
                    { x: startX - dx, y: startY - dy },
                    { x: startX - dx*2, y: startY - dy*2 }
                ];
                players[id].dx = dx;
                players[id].dy = dy;
                players[id].alive = true;
                players[id].score = 0;
                players[id].restartReady = false;
            });

            // Set local snake reference
            if (players[myId]) {
                mySnake = players[myId].snake;
                myDx = players[myId].dx;
                myDy = players[myId].dy;
                myScore = 0;
                myAlive = true;
                myRestartReady = false;
            }

            food = initialFood;
            bomb = createBomb(); // Create initial bomb
            
            // document.getElementById('my-score').textContent = myScore;
            // document.getElementById('opponent-score').textContent = opponentScore;
            
            // Controls already attached on page load - just ensure they're ready
            console.log('[StartGame] Controls should already be attached');
            
            // Start Countdown instead of immediate start
            startCountdown();
        }

        function startCountdown() {
            const overlay = document.getElementById('countdown-overlay');
            const text = document.getElementById('countdown-text');
            let count = 3;
            
            overlay.classList.remove('hidden');
            text.textContent = count;
            
            // Initial draw to show snakes before moving
            draw();
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    text.textContent = count;
                    // Reset animation
                    text.style.animation = 'none';
                    text.offsetHeight; /* trigger reflow */
                    text.style.animation = 'countdownPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                } else if (count === 0) {
                    text.textContent = 'GO!';
                    text.style.animation = 'none';
                    text.offsetHeight; /* trigger reflow */
                    text.style.animation = 'countdownPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                } else {
                    clearInterval(countInterval);
                    overlay.classList.add('hidden');
                    
                    // Start actual game loop
                    isPlaying = true;
                    console.log('[Game Start] isPlaying set to TRUE, myAlive:', myAlive);
                    if (gameInterval) clearInterval(gameInterval);
                    gameInterval = setInterval(gameLoop, GAME_SPEED);
                }
            }, 1000);
        }
        
        // Final Countdown (when 1 player left)
        function startFinalCountdown() {
            const countdownEl = document.getElementById('final-countdown');
            const timeEl = document.getElementById('final-countdown-time');
            let timeLeft = 5;
            
            countdownEl.style.display = 'block';
            timeEl.textContent = timeLeft;
            
            const countInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft > 0) {
                    timeEl.textContent = timeLeft;
                } else {
                    clearInterval(countInterval);
                    countdownEl.style.display = 'none';
                    window.finalCountdownStarted = false;
                    
                    // Determine winner by HIGHEST SCORE
                    const sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);
                    const highestScore = sortedPlayers[0].score;
                    
                    // Check for tie at highest score
                    const winners = sortedPlayers.filter(p => p.score === highestScore);
                    
                    let winnerName;
                    if (winners.length > 1) {
                        winnerName = 'Kimse'; // Tie
                    } else {
                        winnerName = winners[0].name;
                    }
                    
                    // Broadcast game over to all players
                    broadcast({ type: 'gameOver', winner: winnerName });
                    showGameOver(winnerName);
                    isPlaying = false;
                    clearInterval(gameInterval);
                }
            }, 1000);
        }

        // Handle input - SIMPLIFIED with VISUAL FEEDBACK
        function handleKeyPress(event) {
            lastKeyPressed = `${event.key} / ${event.code}`;
            
            // Ignore if typing in input
            const activeTag = document.activeElement ? document.activeElement.tagName : '';
            if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') {
                lastKeyPressed += ' (INPUT ACTIVE)';
                return;
            }
            
            // Must be playing and alive
            if (!isPlaying) {
                lastKeyPressed += ' (NOT PLAYING)';
                return;
            }
            
            if (!myAlive) {
                lastKeyPressed += ' (DEAD)';
                return;
            }
            
            const key = event.key ? event.key.toLowerCase() : '';
            const code = event.code || '';
            
            let handled = false;
            let direction = '';
            
            // Left
            if ((code === 'ArrowLeft' || code === 'KeyA' || key === 'a' || key === 'arrowleft') && myDx !== 1) {
                myDx = -1;
                myDy = 0;
                handled = true;
                direction = 'LEFT';
            }
            // Right  
            else if ((code === 'ArrowRight' || code === 'KeyD' || key === 'd' || key === 'arrowright') && myDx !== -1) {
                myDx = 1;
                myDy = 0;
                handled = true;
                direction = 'RIGHT';
            }
            // Up
            else if ((code === 'ArrowUp' || code === 'KeyW' || key === 'w' || key === 'arrowup') && myDy !== 1) {
                myDx = 0;
                myDy = -1;
                handled = true;
                direction = 'UP';
            }
            // Down
            else if ((code === 'ArrowDown' || code === 'KeyS' || key === 's' || key === 'arrowdown') && myDy !== -1) {
                myDx = 0;
                myDy = 1;
                handled = true;
                direction = 'DOWN';
            }
            
            if (handled) {
                // IMMEDIATELY update player object to prevent sync lag
                if (players[myId]) {
                    players[myId].dx = myDx;
                    players[myId].dy = myDy;
                }
                
                lastKeyPressed += ` -> ${direction} (dx:${myDx},dy:${myDy})`;
                event.preventDefault();
                event.stopPropagation();
            } else {
                lastKeyPressed += ' (IGNORED)';
            }
        }

        // Game loop
        function gameLoop() {
            if (!isPlaying) return;
            
            // Host Logic: Update all snakes and broadcast
            if (isHost) {
                // Update my direction in players object
                if (players[myId]) {
                    players[myId].dx = myDx;
                    players[myId].dy = myDy;
                }
                
                // Move ALL players' snakes
                Object.keys(players).forEach(id => {
                    if (players[id].alive) {
                        moveSnake(id);
                    }
                });
                
                // Check collisions for all players AFTER all have moved
                Object.keys(players).forEach(id => {
                    if (players[id].alive) {
                        checkCollisions(id);
                    }
                });

                // Check Game Over after all collisions
                checkGameOver();

                // Broadcast state
                broadcast({
                    type: 'stateUpdate',
                    players: players,
                    food: food,
                    bomb: bomb
                });
            } else {
                // Guest: Update my player's direction first
                if (players[myId]) {
                    players[myId].dx = myDx;
                    players[myId].dy = myDy;
                }
                
                // Move own snake locally for smooth prediction
                moveSnake(myId);
                
                // DON'T check collisions - let Host be authoritative
                // checkCollisions(myId); // REMOVED
                
                // Send move to host
                if (connection) {
                    connection.send({
                        type: 'move',
                        id: myId,
                        snake: mySnake,
                        score: myScore,
                        alive: myAlive,
                        dx: myDx,
                        dy: myDy
                    });
                }
            }
            
            draw();
        }

        function moveSnake(id) {
            const player = players[id];
            if (!player.alive) return;

            const head = { x: player.snake[0].x + player.dx, y: player.snake[0].y + player.dy };
            player.snake.unshift(head);
            
            // Check food collision
            if (food && food.type && head.x === food.x && head.y === food.y) {
                player.score += food.type.points;
                // Generate new food
                food = createFood();
            } else {
                player.snake.pop();
            }
            
            // Update local refs if it's me
            if (id === myId) {
                mySnake = player.snake;
                myScore = player.score;
                myAlive = player.alive;
            }
        }

        function checkCollisions(id) {
            const player = players[id];
            const head = player.snake[0];

            // Wall Collision
            if (head.x < 0 || head.x >= GRID_COUNT_X || head.y < 0 || head.y >= GRID_COUNT_Y) {
                player.alive = false;
            }

            // Self Collision
            for (let i = 1; i < player.snake.length; i++) {
                if (head.x === player.snake[i].x && head.y === player.snake[i].y) {
                    player.alive = false;
                }
            }

            // Collision with other snakes
            Object.keys(players).forEach(otherId => {
                if (id !== otherId && players[otherId].alive) {
                    const otherHead = players[otherId].snake[0];
                    const otherSnake = players[otherId].snake;
                    
                    // Head-on collision (both die)
                    // Check if heads are on same spot OR if they swapped positions (passed through each other)
                    const swappedPositions = (head.x === otherSnake[1]?.x && head.y === otherSnake[1]?.y) &&
                                           (otherHead.x === player.snake[1]?.x && otherHead.y === player.snake[1]?.y);
                                           
                    if ((head.x === otherHead.x && head.y === otherHead.y) || swappedPositions) {
                        player.alive = false;
                        players[otherId].alive = false;
                    } else {
                        // Collision with other snake's body (only hitter dies, starting from index 1 to skip head)
                        for (let i = 1; i < otherSnake.length; i++) {
                            if (head.x === otherSnake[i].x && head.y === otherSnake[i].y) {
                                player.alive = false;
                                break; // No need to check further
                            }
                        }
                    }
                }
            });
            
            // Bomb Collision
            if (bomb && head.x === bomb.x && head.y === bomb.y) {
                player.score = Math.max(0, player.score - 20);
                bomb = null;
                setTimeout(() => { bomb = createBomb(); }, 5000);
            }
        }

        function checkGameOver() {
            if (!isPlaying) return;
            
            const alivePlayers = Object.values(players).filter(p => p.alive);
            
            // Start final countdown if only 1 player left - with small delay to ensure collision checks complete
            if (alivePlayers.length === 1 && Object.keys(players).length > 1 && !window.finalCountdownStarted) {
                window.finalCountdownStarted = true;
                // Small delay to ensure all collision checks are complete
                setTimeout(() => {
                    const stillAlive = Object.values(players).filter(p => p.alive);
                    if (stillAlive.length === 1) {
                        startFinalCountdown();
                    }
                }, 100);
            }
            // End game immediately if no one left - determine winner by SCORE
            else if (alivePlayers.length === 0 && Object.keys(players).length > 1) {
                const sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);
                const highestScore = sortedPlayers[0].score;
                const winners = sortedPlayers.filter(p => p.score === highestScore);
                
                let winnerName = winners.length > 1 ? 'Kimse' : winners[0].name;
                
                broadcast({ type: 'gameOver', winner: winnerName });
                showGameOver(winnerName);
                isPlaying = false;
                clearInterval(gameInterval);
            }
        }

        // Update my snake
        function updateMySnake() {
            const newHead = { x: mySnake[0].x + myDx, y: mySnake[0].y + myDy };
            
            // Check wall collision
            if (newHead.x < 0 || newHead.x >= GRID_COUNT_X || newHead.y < 0 || newHead.y >= GRID_COUNT_Y) {
                myAlive = false;
                return;
            }
            
            // Check self collision
            for (let segment of mySnake) {
                if (segment.x === newHead.x && segment.y === newHead.y) {
                    myAlive = false;
                    return;
                }
            }
            
            // Check collision with opponents
            Object.keys(players).forEach(id => {
                if (id !== myId && players[id].alive) {
                    const otherSnake = players[id].snake;
                    for (let segment of otherSnake) {
                        if (segment.x === newHead.x && segment.y === newHead.y) {
                            myAlive = false;
                        }
                    }
                }
            });
            
            if (!myAlive) return;
            
            mySnake.unshift(newHead);
            
            // Check food
            if (newHead.x === food.x && newHead.y === food.y) {
                myScore += food.type.points;
                // document.getElementById('my-score').textContent = myScore;
                
                if (isHost) {
                    food = createFood();
                    bomb = createBomb(); // New bomb chance
                    if (connection) {
                        connection.send({ type: 'foodUpdate', food: food });
                        connection.send({ type: 'bombUpdate', bomb: bomb });
                    }
                }
            } else if (bomb && newHead.x === bomb.x && newHead.y === bomb.y) {
                // Hit bomb! Lose points and shrink
                myScore = Math.max(0, myScore - 20);
                // document.getElementById('my-score').textContent = myScore;
                
                // Trigger explosion effect
                explosion = {
                    x: bomb.x * GRID_SIZE + GRID_SIZE / 2,
                    y: bomb.y * GRID_SIZE + GRID_SIZE / 2,
                    frame: 0,
                    maxFrames: 20
                };
                
                // Remove 3 segments (shrink snake)
                for (let i = 0; i < 3 && mySnake.length > 3; i++) {
                    mySnake.pop();
                }
                
                if (isHost) {
                    bomb = createBomb(); // Respawn bomb
                    if (connection) {
                        connection.send({ type: 'bombUpdate', bomb: bomb });
                    }
                }
            } else {
                mySnake.pop();
            }
        }

        // Draw
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw Map Background
            if (currentMap) {
                ctx.fillStyle = currentMap.bgColor;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw Grid
                ctx.strokeStyle = currentMap.gridColor;
                ctx.lineWidth = 1;
                for (let x = 0; x <= CANVAS_WIDTH; x += GRID_SIZE) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke();
                }
                for (let y = 0; y <= CANVAS_HEIGHT; y += GRID_SIZE) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke();
                }
                
                // Draw Map Pattern
                if (currentMap.drawPattern) {
                    currentMap.drawPattern(ctx);
                }
            }

            // Draw Food with glowing effect
            if (food && food.type) {
                const x = food.x * GRID_SIZE;
                const y = food.y * GRID_SIZE;

                // Create pulsing glow effect
                const pulse = Math.sin(Date.now() / 300) * 0.4 + 0.8;
                
                // Draw outer glow (pulsing)
                const glowGradient = ctx.createRadialGradient(
                    x + GRID_SIZE / 2,
                    y + GRID_SIZE / 2,
                    0,
                    x + GRID_SIZE / 2,
                    y + GRID_SIZE / 2,
                    GRID_SIZE * 1.2 * pulse
                );
                glowGradient.addColorStop(0, food.type.color + 'AA');
                glowGradient.addColorStop(0.3, food.type.color + '80');
                glowGradient.addColorStop(0.6, food.type.color + '40');
                glowGradient.addColorStop(1, food.type.color + '00');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(
                    x + GRID_SIZE / 2,
                    y + GRID_SIZE / 2,
                    GRID_SIZE * 1.2 * pulse,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Add shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // Semi-transparent background
                ctx.fillStyle = food.type.color + '40';
                ctx.beginPath();
                ctx.arc(
                    x + GRID_SIZE / 2,
                    y + GRID_SIZE / 2,
                    GRID_SIZE / 1.7,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Draw emoji
                ctx.font = `bold ${GRID_SIZE * 1.2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    food.type.emoji,
                    x + GRID_SIZE / 2,
                    y + GRID_SIZE / 2 + 2
                );
            }

            // Draw Bomb with enhanced effect
            if (bomb) {
                drawBomb();
            }

            // Draw Explosion
            if (explosion) {
                ctx.font = '30px Arial';
                ctx.fillText('üí•', explosion.x * GRID_SIZE + GRID_SIZE/2, explosion.y * GRID_SIZE + GRID_SIZE/2);
                explosion.frame++;
                if (explosion.frame > 5) explosion = null;
            }

            // Draw All Snakes
            Object.keys(players).forEach(id => {
                const player = players[id];
                if (!player.alive) return;
                
                const skin = SNAKE_SKINS.find(s => s.id === player.skinId) || SNAKE_SKINS[0];
                const isMe = id === myId;
                
                drawSnake(player.snake, skin.head, skin.body, skin.glow, isMe, player.name, player.dx, player.dy);
            });
            
            // Update Scoreboard
            
            // Update Scoreboard
            updateScoreBoard();
        }

        function updateScoreBoard() {
            const board = document.getElementById('score-board');
            if (!board) return;
            
            board.innerHTML = '';
            
            // Sort players by score
            const sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);
            
            sortedPlayers.forEach(p => {
                const item = document.createElement('div');
                item.className = 'score-item';
                if (!p.alive) item.style.opacity = '0.5';
                
                // Get player skin color for score
                const skin = SNAKE_SKINS.find(s => s.id === p.skinId) || SNAKE_SKINS[0];
                const scoreColor = skin.head || '#6366f1';

                item.innerHTML = `
                    <div class="score-label" style="color: #cbd5e1; font-size: 15px; font-weight: 600;">${p.name}</div>
                    <div class="score-value" style="color: ${scoreColor}; text-shadow: 0 0 10px ${scoreColor}40; font-size: 28px; font-weight: bold;">${p.score}</div>
                `;
                board.appendChild(item);
            });
        }

        function drawSnake(snake, headColor, bodyColor, glowColor, isMe, name, dx, dy) {
            // Add strong but soft shadow (Glow effect)
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            snake.forEach((segment, index) => {
                const x = segment.x * GRID_SIZE;
                const y = segment.y * GRID_SIZE;

                if (index === 0) {
                    // Head
                    ctx.fillStyle = headColor;
                    // Reset shadow for head rect to avoid double shadow with glow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Draw glowing head background if needed, or just the head
                    // For consistency with singleplayer, we just draw the head
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                    ctx.shadowBlur = 12;
                    ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    
                    // Eyes
                    ctx.fillStyle = '#000'; // Black eyes
                    const eyeSize = 4;
                    const eyeOffset = 6;
                    
                    // Reset shadow for eyes
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    if (dx === 1) { // Moving right
                        ctx.fillRect(x + GRID_SIZE - eyeOffset, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - eyeOffset, y + GRID_SIZE - 9, eyeSize, eyeSize);
                    } else if (dx === -1) { // Moving left
                        ctx.fillRect(x + 2, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + 2, y + GRID_SIZE - 9, eyeSize, eyeSize);
                    } else if (dy === -1) { // Moving up
                        ctx.fillRect(x + 5, y + 2, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - 9, y + 2, eyeSize, eyeSize);
                    } else if (dy === 1) { // Moving down
                        ctx.fillRect(x + 5, y + GRID_SIZE - eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - 9, y + GRID_SIZE - eyeOffset, eyeSize, eyeSize);
                    } else {
                        // Default (Right)
                        ctx.fillRect(x + GRID_SIZE - eyeOffset, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - eyeOffset, y + GRID_SIZE - 9, eyeSize, eyeSize);
                    }
                    
                    // Name tag
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Poppins';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(name, x + GRID_SIZE/2, y - 5);
                    
                    // Restore shadow for next segments
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                    ctx.shadowBlur = 12;

                } else {
                    // Body
                    // Fading effect: Opacity decreases towards the tail
                    const opacity = Math.max(0.3, 1 - (index / (snake.length + 5)));
                    ctx.globalAlpha = opacity;
                    
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    
                    ctx.globalAlpha = 1.0; // Reset opacity
                }
            });
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }


        // Draw food
        function drawFood() {
            const x = food.x * GRID_SIZE;
            const y = food.y * GRID_SIZE;
            
            const pulse = Math.sin(Date.now() / 300) * 0.5 + 1.0; // Enhanced
            
            const glowGradient = ctx.createRadialGradient(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                0,
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE * 1.5 * pulse // Larger
            );
            glowGradient.addColorStop(0, food.type.color + 'CC'); // More opaque
            glowGradient.addColorStop(0.3, food.type.color + 'AA');
            glowGradient.addColorStop(0.6, food.type.color + '66');
            glowGradient.addColorStop(1, food.type.color + '00');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE * 1.5 * pulse,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Add shadow for prominence
            ctx.shadowColor = food.type.color;
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = food.type.color + '60'; // More opaque
            ctx.beginPath();
            ctx.arc(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE / 1.5, // Larger
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            ctx.font = `bold ${GRID_SIZE * 1.4}px Arial`; // Larger
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                food.type.emoji,
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2 + 2
            );
        }
        
        // Draw bomb with ENHANCED glowing effect
        function drawBomb() {
            const x = bomb.x * GRID_SIZE;
            const y = bomb.y * GRID_SIZE;
            
            // Create pulsing red glow effect (ENHANCED)
            const pulse = Math.sin(Date.now() / 200) * 0.5 + 1.0; // Faster, more dramatic
            
            // Draw outer glow (red, pulsing) - LARGER
            const glowGradient = ctx.createRadialGradient(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                0,
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE * 1.5 * pulse // Increased from 1.2
            );
            glowGradient.addColorStop(0, '#FF0000CC'); // More opaque
            glowGradient.addColorStop(0.3, '#FF0000AA');
            glowGradient.addColorStop(0.6, '#FF000066');
            glowGradient.addColorStop(1, '#FF000000');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE * 1.5 * pulse,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Add strong shadow
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Background circle - LARGER
            ctx.fillStyle = '#FF000060'; // More opaque
            ctx.beginPath();
            ctx.arc(
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2,
                GRID_SIZE / 1.5, // Larger
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Reset shadow for emoji
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Draw LARGE bomb emoji
            ctx.font = `bold ${GRID_SIZE * 1.4}px Arial`; // Increased from 1.2
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                'üí£',
                x + GRID_SIZE / 2,
                y + GRID_SIZE / 2 + 2
            );
        }
        
        // Draw explosion effect
        function drawExplosion() {
            const progress = explosion.frame / explosion.maxFrames;
            const radius = GRID_SIZE * 3 * progress; // Expanding radius
            const alpha = 1 - progress; // Fading out
            
            // Outer expanding ring (orange)
            const gradient1 = ctx.createRadialGradient(
                explosion.x, explosion.y, 0,
                explosion.x, explosion.y, radius
            );
            gradient1.addColorStop(0, `rgba(255, 200, 0, ${alpha * 0.8})`);
            gradient1.addColorStop(0.5, `rgba(255, 100, 0, ${alpha * 0.6})`);
            gradient1.addColorStop(1, `rgba(255, 0, 0, 0)`);
            
            ctx.fillStyle = gradient1;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner bright flash
            if (progress < 0.3) {
                const flashAlpha = (1 - progress / 0.3) * 0.9;
                ctx.fillStyle = `rgba(255, 255, 200, ${flashAlpha})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, GRID_SIZE * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Particles flying out
            const particleCount = 8;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const dist = radius * 0.8;
                const px = explosion.x + Math.cos(angle) * dist;
                const py = explosion.y + Math.sin(angle) * dist;
                
                ctx.fillStyle = `rgba(255, 150, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function showGameOver(winnerName) {
            const overlay = document.getElementById('game-over-overlay');
            const title = document.getElementById('game-over-title');
            const message = document.getElementById('game-over-message');
            const restartStatus = document.getElementById('restart-status');
            
            if (winnerName === myName) {
                title.innerText = '‚úÖ Kazandƒ±nƒ±z!';
                title.style.color = '#10b981'; // Green
                title.style.textShadow = '0 0 20px rgba(16, 185, 129, 0.5)';
                message.innerText = `Skorunuz: ${myScore}`;
                message.style.color = '#34d399';
            } else if (winnerName && winnerName !== 'Kimse') {
                title.innerText = '‚ùå Kaybettiniz!';
                title.style.color = '#ef4444'; // Red
                title.style.textShadow = '0 0 20px rgba(239, 68, 68, 0.5)';
                message.innerText = `Kazanan: ${winnerName}`;
                message.style.color = '#f87171';
            } else {
                title.innerText = 'ü§ù Berabere!';
                title.style.color = '#fbbf24'; // Yellow
                title.style.textShadow = '0 0 20px rgba(251, 191, 36, 0.5)';
                message.innerText = `Herkes elendi!`;
                message.style.color = '#fcd34d';
            }
            
            restartStatus.innerText = 'Tekrar oynamak i√ßin hazƒ±r ol';
            overlay.classList.remove('hidden');
        }

        // Show game over
        function showGameOver(winnerName) {
            const overlay = document.getElementById('game-over-overlay');
            const title = document.getElementById('game-over-title');
            const message = document.getElementById('game-over-message');
            
            if (winnerName === myName) {
                title.textContent = 'üèÜ Kazandƒ±nƒ±z!';
                message.textContent = `Skorunuz: ${myScore}`;
            } else if (winnerName && winnerName !== 'Kimse') {
                title.textContent = 'üò≠ Kaybettiniz!';
                message.textContent = `Kazanan: ${winnerName}`;
            } else {
                title.textContent = 'ü§ù Berabere!';
                message.textContent = `Herkes elendi!`;
            }
            
            overlay.classList.remove('hidden');
            overlay.style.display = 'flex';
        }

        // Ready for restart
        function readyForRestart() {
            myRestartReady = true;
            if (players[myId]) {
                players[myId].restartReady = true;
            }
            updateRestartStatus();
            
            if (connection) {
                // Guest: Send to Host with ID
                connection.send({ type: 'restartReady', id: myId, ready: true });
            } else if (isHost) {
                // Host: Broadcast to all
                broadcast({ type: 'restartReady', id: myId, ready: true });
                checkAllReadyForRestart();
            }
        }
        
        // Update restart status display
        function updateRestartStatus() {
            const statusEl = document.getElementById('restart-status');
            const totalPlayers = Object.keys(players).length;
            const readyCount = Object.values(players).filter(p => p.restartReady).length;
            
            if (myRestartReady) {
                if (readyCount === totalPlayers) {
                    statusEl.textContent = 'üéÆ Oyun yeniden ba≈ülƒ±yor...';
                    statusEl.style.color = '#10b981';
                } else {
                    statusEl.textContent = `‚úì Hazƒ±rsƒ±n! (${readyCount}/${totalPlayers})`;
                    statusEl.style.color = '#f59e0b';
                }
            } else {
                statusEl.textContent = `Tekrar oynamak i√ßin hazƒ±r ol (${readyCount}/${totalPlayers})`;
                statusEl.style.color = '#94a3b8';
            }
        }
        
        // Check if all ready for restart
        function checkAllReadyForRestart() {
            const allReady = Object.values(players).every(p => p.restartReady);
            if (allReady && Object.keys(players).length >= 2) {
                if (isHost) {
                    const newFood = createFood();
                    if (connection) {
                        // connection.send({ type: 'restart', food: newFood }); // Deprecated for host-multicast
                        broadcast({ type: 'restart', food: newFood });
                    } else {
                         broadcast({ type: 'restart', food: newFood });
                    }
                    setTimeout(() => restartGame(newFood), 1000);
                }
            }
        }
        
        // Restart game
        function restartGame(initialFood) {
            // Reset restart ready states
            myRestartReady = false;
            Object.keys(players).forEach(id => {
                players[id].restartReady = false;
            });
            
            // Hide game over overlay
            document.getElementById('game-over-overlay').classList.add('hidden');
            
            // Start new game WITHOUT resetting scores
            startGame(initialFood, false);
        }

        // Copy game ID
        // Toggle ID Visibility
        // Toggle ID Visibility
        function toggleIdVisibility() {
            const idDisplay = document.getElementById('game-id-display');
            const idMask = document.getElementById('game-id-mask');
            
            if (idDisplay.style.display === 'none') {
                // Show ID
                idDisplay.style.display = 'block';
                idMask.style.display = 'none';
            } else {
                // Hide ID
                idDisplay.style.display = 'none';
                idMask.style.display = 'block';
            }
        }

        // Copy Game ID
        function copyGameId() {
            const idDisplay = document.getElementById('game-id-display');
            const id = idDisplay.textContent;
            
            if (!id || id === '----') return;
            
            navigator.clipboard.writeText(id).then(() => {
                const btn = document.querySelector('.lobby-header .btn-primary');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Kopyalandƒ±!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Kopyalama hatasƒ±:', err);
                alert('ID kopyalanamadƒ±: ' + id);
            });
        }

        // Back to menu
        function backToMenu() {
            location.reload();
        }
        
        // Mobile Swipe Controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        const gameCanvas = document.getElementById('game-canvas');
        
        if (gameCanvas) {
            gameCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: false });
            
            gameCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            gameCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!isPlaying || !myAlive) return;
                
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: false });
        }
        
        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0 && myDx !== -1) {
                        // Swipe right
                        myDx = 1;
                        myDy = 0;
                        if (players[myId]) {
                            players[myId].dx = myDx;
                            players[myId].dy = myDy;
                        }
                    } else if (deltaX < 0 && myDx !== 1) {
                        // Swipe left
                        myDx = -1;
                        myDy = 0;
                        if (players[myId]) {
                            players[myId].dx = myDx;
                            players[myId].dy = myDy;
                        }
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0 && myDy !== -1) {
                        // Swipe down
                        myDx = 0;
                        myDy = 1;
                        if (players[myId]) {
                            players[myId].dx = myDx;
                            players[myId].dy = myDy;
                        }
                    } else if (deltaY < 0 && myDy !== 1) {
                        // Swipe up
                        myDx = 0;
                        myDy = -1;
                        if (players[myId]) {
                            players[myId].dx = myDx;
                            players[myId].dy = myDy;
                        }
                    }
                }
            }
        }
        
        // Add keyboard event listener for WASD controls
        document.addEventListener('keydown', handleKeyPress);

        // Prevent default scrolling on mobile when playing
        document.addEventListener('touchmove', function(e) {
            if (isPlaying) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Add .hidden class definition dynamically if not exists
        const style = document.createElement('style');
        style.textContent = `
            .hidden {
                display: none !important;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
